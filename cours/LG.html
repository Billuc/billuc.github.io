<!DOCTYPE html>
<html lang="fr" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./coursStyle.css">
    <title>Vidéos - Grammaire et Langages</title>
  </head>
  <body>
    <div class="title">
      <h1>Grammaire et Langages</h1>
      <h2>Videos</h2>
    </div>
    <div class="chapitre" id="intro">
      <h2>Introduction générale</h2>
      <p>
        <b>Grammaires et Langages</b> : concepts théoriques en informatique mais assez
        fondamentaux.
      </p>
      <p>
        <b>3 domaines d'application : </b>
        <ul>
          <li><b>Analyse</b> : savoir si une phrase correspond à une grammaire donnée et
          traiter les résultats (le plus courant)</li>
          <li><b>Synthèse</b> : générer des phrases d'une grammaire donnée</li>
          <li><b>Inférence grammaticale</b> : générer une grammaire à partir d'échantillons
          du langage.</li>
        </ul>
      </p>
      <div class="encadre">
        <b>Definitions</b> : <br>
        <i>Grammaire</i> : décrit une syntaxe d'écriture à l'aide de règles <br>
        <i>Langage</i> : ensemble de phrases d'un alphabet <br>
        <small>Pour les grammaires, on ne parle pas d'alphabet mais de symboles terminaux </small><br>
      </div>
      <p>
        <i>Exemples de langages</i> :
        <ul>
          <li><span class="formule">{a*b*}</span> : suite de 'a' (nb qcq) suivi d'une suite de 'b' (nb qcq) <br>
          &rarr; langage régulier</li>
          <li><span class="formule">{a&#8319; b&#8319; / n>0}</span> : suite de n 'a' suivi de n 'b' (contrainte : mm nombre) <br>
          &rarr; langage non-régulier hors-contexte</li>
          <li><span class="formule">{a&#8319; b&#8319; c&#8319; / n>0}</span> : n 'a' puis n 'b' puis n 'c' <br>
          &rarr; langage contextuel (outils plus compliqués)</li>
        </ul>
        <i>Exemple de grammaire pour le langage {a*b*}</i> : <br>
        <span class="formule">
          EXP &rarr; a EXP | b EXP2 | &#949; <br>
          EXP2 &rarr; b EXP2 | &#949;
        </span>
        "&rarr;" signifie "produit", '|' signifie "ou", "&#949;" signifie "production vide"
      </p>
      <p>
        <b>Notations</b> : <br>
        Les symboles d'un alphabet (symboles terminaux) sont notés par des lettres minuscules <br>
        Les mots d'un alphabet aussi <br>
        Les symboles non-terminaux sont notés avec des lettres majuscules (ex : EXP)
      </p>
      <div class="encadre">
        <b>Définitions</b> : <br>
        <i>Proto-mot</i> : Mot avec des symboles terminaux et non-terminaux noté avec une lettre grecque <br>
        <i>Dérivation</i> : rééecriture d'un proto-mot par application d'une règle (notée &rArr;) <br>
        <i>Phrase générée par une grammaire</i> : phrase déduite par dérivations de l'axiome (symbole de départ) de la grammaire <br>
        <i>Langage généré par une grammaire</i> : ensemble des phrases générées par dérivations
      </div>
      <div class="encadre">
          <b>Classification des grammaires</b><br>
          Grammaires à choix finis (type 4) incluses dans <br>
          Grammaires régulières (type 3) incluses dans <br>
          Grammaires hors contexte (type 2) incluses dans <br>
          Grammaires contextuelles (type 1) incluses dans <br>
          Grammaires générales (type 0) (plus de contraintes)<br>
          <br>
          <b>Notations</b> : <br>
          <ul>
            <li>T : ensemble des symboles terminaux (ou alphabet)</li>
            <li>N : ensemble des symboles non-terminaux</li>
            <li>R : ensemble des règles de la grammaire</li>
            <li>S : l'axiome de la grammaire (le symbole de départ) (S appartient à N)</li>
            <li>V : T union N</li>
          </ul>
        <p>
          <b>Grammaires générales : </b><br>
          <span class="formule">&#945; &rarr; &#946;</span>
          <small>Avec &#945; dans V*NV* et &#946; dans V*</small><br>
          Difficiles à analyser car boucle si n'appartient pas au langage (indécidable)
        </p>
        <p>
          <b>Grammaires contextuelles (ou croissantes) : </b><br>
          <span class="formule">&#945; A &#946; &rarr; &#945; &#947; &#946;</span>
          <small>Avec A dans N et &#945;, &#946;, &#947; dans V*</small><br>
          Les langages générés sont dits contextuels.
        </p>
        <p>
          <b>Grammaires hors contexte : </b><br>
          <span class="formule">A &rarr; &#947;</span>
          <small>Avec A dans N et &#947; dans V*</small><br>
          Grammaires très utilisées pour la définition de langages de programmation
          car analyse très aisée et possible. Si &#947; dans N, grammaire linéaire.
        </p>
        <p>
          <b>Grammaires régulières (ou rationnelles) : </b><br>
          Généralement sous la forme d'expressions régulières ou automates finis
          <span class="formule">A &rarr; a B</span>
          <span class="formule">A &rarr; b</span>
          <small>Avec A, B dans N et a, b dans T</small><br>
        </p>
        <p>
          <b>Grammaires à choix finis : </b><br>
          <span class="formule">A &rarr; a</span>
          <small>Avec A dans N et a dans T+</small><br>
        </p>
      </div>
      <br>
      <table>
        <th colspan="2"><b>Notation BNF (Backus Naur Form) : </b></th>
        <tr>
          <td>::=</td>
          <td>est le symbole de définition d'une règle (eq &rarr;)</td>
        </tr>
        <tr>
          <td>|</td>
          <td>est le 'ou'</td>
        </tr>
        <tr>
          <td>< ></td>
          <td>pour un symbole non-terminal</td>
        </tr>
        <tr>
          <td>[ ]</td>
          <td>pour une partie facultative</td>
        </tr>
        <tr>
          <td>{ }</td>
          <td>pour grouper des éléments</td>
        </tr>
        <tr>
          <td>" "</td>
          <td>pour les terminaux d'un seul caractère</td>
        </tr>
        <th colspan="2">EBNF (version étendue) : </th>
        <tr>
          <td>?</td>
          <td>si c'est optionnel</td>
        </tr>
        <tr>
          <td>*</td>
          <td>pour la répétition de 0 à n fois</td>
        </tr>
        <tr>
          <td>+</td>
          <td>pour la répétition de 1 à n fois</td>
        </tr>
      </table>
    </div>
    <div class="chapitre" id="ana_lexicale">
      <h2>Analyse lexicale</h2>
      <h3>Langages et expressions rationnels</h3>
      <div class="encadre">
        <b>Definitions</b><br>
        Les langages et expressions rationnels peuvent être définis de manière inductive/recursive.<br><br>
        Un <b>langage régulier</b> est défini par :
        <ul>
          <li>{&#949;} et &#216; sont des langages réguliers</li>
          <li>pour tout a dans &Sigma; (l'alphabet), {a} est un langage régulier</li>
          <li>si L1 et L2 sont des langages rationnels, alors L1 union L2, L1 L2 et L1* aussi</li>
        </ul>
        Une <b>expression régulière</b> est définie par :
        <ul>
          <li>&epsilon; est une expression régulière (mot de longueur nulle)</li>
          <li>&#216; est une expression regulière signifiant l'absence de mot</li>
          <li>pour tout a dans &Sigma;, a est une expression régulière</li>
          <li>si e1 et e2 sont des expressions régulières, (e1+e2) <small>(ou)</small>, (e1 e2) <small>(concat)</small> et (e1*) aussi</li>
        </ul>
      </div>
      <p>
        <b>Propriétés et règles simples : </b><br>
        <ul>
          <li><span class="formule">&epsilon;e = e&epsilon; = e</span></li>
          <li><span class="formule">&#216;e = e&#216; = e</span></li>
          <li>le + est commutatif (pas le concat)</li>
          <li>le + et le concat sont associatifs</li>
          <li><span class="formule">e1 (e2 + e3) = e1 e2 + e1 e3</span></li>
          <li>Priorité d'opérateurs : *, concat et +</li>
          <li><span class="formule">&#216; + e = e + &#216; = e</span></li>
          <li><span class="formule">e + e = e</span></li>
          <li><span class="formule">e* e* = e*</span></li>
          <li><span class="formule">(e*)* = e*</span></li>
          <li>etc.</li>
        </ul>
      </p>
      <p>
        Toute expression régulière décrit un et un seul langage régulier.<br>
        Deux expressions régulières décrivant un même langage sont équivalentes.
      </p>
      <h3>Les Automates Finis</h3>
      <div class="encadre">
        <b>Définitions : </b><br>
        Un automate fini déterministe est défini par :
        <ul>
          <li>&Sigma; un ensemble fini de symboles (ou alphabet)</li>
          <li>Q un ensemble fini d'états</li>
          <li>q0 de Q, l'état initial</li>
          <li>F inclus dans Q, l'ensemble des états finaux</li>
          <li>&delta; une fonction totale de Q * &Sigma; &rarr; Q, appellée fonction de transition</li>
        </ul>
        <small>Cet automate est déterministe car chaque couple (q, a) de Q * &Sigma; n'a qu'une valeur
        dans la fonction de transition.</small>
      </div>
      <p>
        En pratique, on n'exprime pas la totalité des transitions et on considère qu'on
        arrive dans un état d'erreur si la transition n'est pas explicitée.<br>
        On représente aussi la fonction de transition par une table de transition.<br>
        On représente l'automate fini par un graphe orientés où les états sont les noeuds
        et les symboles sont des étiquettes sur les arcs.
      </p>
      <div class="encadre">
        Un <b>automate déterministe</b> permet de reconnaître les mots d'un langage.<br>
        Soit &alpha; un mot. &alpha; est reconnu par l'automate A, si &delta;*(q0, &alpha;) appartient a F avec: <br>
        <ul>
          <li><span class="formule">&delta;*(q, u) = &delta;(q, u) si |u| = 1</span></li>
          <li><span class="formule">&delta;*(q, au) = &delta;*(&delta;(q, a), u) sinon</span></li>
        </ul>
        &delta;* est donc l'application successive de &delta; sur tout le mot &alpha;.<br>
        Si l'application de &delta;* n'amène pas à un état final, le mot n'est pas reconnu.<br>
      </div>
      <p>
        L'ensemble des mots reconnus par A est le langage reconnu par A.
      </p>
      <div class="encadre">
        <b>Méthode des dérivées</b><br>
        Permet de trouver un automate à partir de son expression.<br>
        Pour cela, on va dériver l'expression par rapport à un symbole.
        <span class="formule">Da(e) = {u | au appartient à e}</span>
        La dérivée de e par rapport à a est tout ce qui peut suivre a dans e (sachant que e commence par a).
        <b>Propriétés : </b>
        <ul>
          <li> <span class="formule">Da(a) = &epsilon;</span> </li>
          <li> <span class="formule">Da(b) = &#216;</span> </li>
          <li> <span class="formule">Da(e1 + e2) = Da(e1) + Da(e2)</span> </li>
          <li> <span class="formule">Da(e1e2) = Da(e1)e2 + &Delta;(e1)Da(e2)</span><br>
          On dérive e1 et on concatène e2 si e1 ne peut pas être de longueur nulle.
          Sinon, on dérive aussi e2.</li>
          <li> <span class="formule">Da(e*) = Da(e)e*</span> </li>
        </ul>
        Les états de l'automate sont les dérivées successives de l'expression.<br>
        Il y a une transition entre ei et ej sur le symbole a si Da(ej) = ei.<br>
        Un état sera final si le langage qu'il génère contient le mot vide (si on peut avoir un mot de longueur nulle).
      </div>
      <p>Il existe aussi une manière très simple de générer l'automate fini d'une
      expression mais cet automate sera non-déterministe.</p>
      <div class="encadre">
        Un <b>automate fini non-déterministe</b> est aussi défini par &Sigma;, Q, q0, F et &delta;.<br>
        La différence se fait sur le &delta; qui est maintenant une fonction de Q * &Sigma; vers 2^Q.<br>
        2^Q est l'ensemble des sous-ensembles de Q.<br>
        Il existe aussi des transitions spontanées (&epsilon;-transitions), où le symbole est &epsilon;
      </div>
      <p>
        La méthode de constuction de l'automate fini non-deterministe permet de produire des
        briques d'automate avec un état initial et un état final.
      </p>
      <div class="encadre">
        <b>Construction de Thomson : </b><br>
        <ul>
          <li>Pour un ensemble vide : pas de connexion entre l'initial et le final</li>
          <li>Pour le mot vide : &epsilon;-transition entre l'initial et le final</li>
          <li>Pour un symbole : une transition avec ce symbole entre les 2</li>
          <li>Pour un 'ou' : 2 branches avec des &epsilon;-transitions et les automates des expressions sur chaque branche</li>
          <li>Pour une concat : les automates des 2 expressions à la suite avec des &epsilon;-transitions</li>
          <li>Pour l'operateur de Kleene (e*) : on a l'automate de l'expression entre les 2 états et des &epsilon;-transitions
          entre les 2 états (I&rarr;F pour 0 répétitions et F&rarr;I pour répeter)</li>
        </ul>
      </div>
      <b>Théorème de Kleene : </b>un langage est reconnaissable par un automate fini ssi il est rationnel.
      <p>
        <b>Implémentation des automates</b><br>
        Un automate déterministe peut s'implémenter de manière procédurale, sans
        mémoire. Il suffit d'appeler la fonction de l'état cible de la transition.<br>
        On peut aussi utiliser une table de transition : map < int, map < int, int >><br>
        <small>où le premier int est l'état courant, le deuxième le symbole et le troisième l'état cible</small><br>
        <br>
        Pour un automate non-déterministe, c'est plus complexe, puisque &delta; arrive vers un ensemble d'états.<br>
        On a donc une : map < int, map < int, set < int > > ><br>
        Implémentation généralement 'de front' : on stocke des états courants, qu'on met a jour quand on lit un symbole, jusqu'a un état final.<br>
        <br>
        La complexité est bien moins importante quand l'automate est déterministe.
      </p>
      <p>
        <b>Déterminisation d'un automate : </b><br>
        On veut transformer un automate non-deterministe en automate déterministe
        pour réduire la complexité à l'execution.<br>
        Pour cela, on parcourt l'automate non-déterministe. Les noeuds de l'automate
        déterministe représentent l'ensemble des états courants dans l'automate non-déterministe.<br>
        Pour chaque ensemble d'état, on checke toutes les transitions possibles et on ajoute
        les noeuds et transitions correspondantes dans l'automate déterministe.<br>
        <small>Attention : la taille du nouvel automate peut atteindre 2^(nb de noeuds de départ)</small>
      </p>
      <p>On peut minimiser les automates obtenus (fusionner les noeuds similaires)</p>
    <!-- </div>
    <div class="chapitre" id="ana_lexicale_outils"> -->
      <h2>Analyse lexicale - Outils</h2>
      <p>
        <b>Extensions : </b><br>
        Il y a souvent des extensions (EREs) à la concatenation, l'union et l'opérateur
        de Kleene pour simplifier l'écriture.
        <ul>
          <li> <i>Classes de caractères : </i>
            <ul>
              <li><b>[...]</b> : liste de caractères autorisés (ou non-autorisés si on commence par ^)</li>
              <li>Certaines classes sont prédéclarées, comme <b>[:alpha:]</b> ou <b>[:digit:]</b></li>
              <li>Le <b>.</b> : n'importe quel caractère</li>
            </ul>
          </li>
          <li>
            <i>Cardinalités : </i>
            <ul>
              <li><b>?</b> : 0 ou 1 (donc optionnel)</li>
              <li><b>+</b> : 1 à n</li>
              <li><b>{n1, n2}</b> : de n1 à n2 caractères (Attention, très gros automates)</li>
            </ul>
          </li>
        </ul>
      </p>
      <p>
        <b>POSIX : </b><br>
        Il existe des outils CLI unix pour travailler sur des chaînes de caractères :
        <ul>
          <li><b>grep</b> filtre les lignes correspondant à une regex</li>
          <li><b>ed</b> : (vieil) éditeur de texte pour faire des modifs avec des regex</li>
          <li><b>sed</b> : editeur de flux qui lit et associe des commandes quand une regex correspond</li>
          <li><b>awk</b> : sed++</li>
          <li><b>vi</b> : editeur de texte avec qqs commandes avec regex</li>
        </ul>
        <br>
        Il y a aussi une biblio std pour utiliser les regex :
        <ul>
          <li><b>regcomp()</b> compile la regex (fabrique l'automate)</li>
          <li><b>regexec()</b> teste si la chaine satisfait la regex (execute l'automate)</li>
        </ul>
        On oublie pas de regfree() à la fin ;)
      </p>
      <p>
        <b>C++ : </b><br>
        Il y a une biblio std intégrée à la STL pour faire des regex. Attention,
        utilisez Clang/libc++ ou VS2012+.
      </p>
    </div>
    <div class="chapitre" id="ana_syntaxique">
      <h2>Analyse Syntaxique - Introduction</h2>
      <p>Rappel : grammaire hors-contexte = <span class="formule">A &rarr; &gamma;</span>
        <small>A dans N (non-terminal) et &gamma; dans V*</small><br>
        Pas aussi générales que les contextuelles mais assez expressives quand meme.<br>
      </p>
      <p>
        <b>2 manières d'analyser une grammaire hors-contexte : </b>
        <ul>
          <li>Descendante (top-down) : on part de l'axiome et on dérive jusqu'à arriver aux symboles terminaux de la phrase à analyser</li>
          <li>Ascendante (bottom-up) : on part de la phrase à analyser et on identifie des parties droites de règles (on obtient des proto-mots) jusqu'à arriver à l'axiome</li>
        </ul>
      </p>
      <p>
        <b>Algorithmes : </b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;Pour l'analyse descendante, on a une fonction avec comme parametres le proto-mot
        courant et la phrase à analyser. Elle va chercher les règles associées au premier
        non-terminal du proto-mot et procéder recursivement au remplacement. On s'arrete
        quand le proto-mot = la phrase à analyser.<br>
        Problèmes : on peut boucler à l'infini, si une des règles est récursive /
        on recherche tous les proto-mots sans tenir compte de la phrase (une heuristique
        serait pas mal) / ne marche quasi que dans des cas dégénérés (grammaires à choix finis)<br>
        On peut s'assurer que les règles génèrent des symboles de la phrase (mais on
        ne peut pas avoir de non-terminaux au début &rarr; grammaires linéraires)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;Pour l'analyse ascendante, on inverse l'analyse des règles.
        Cette fois-ci, on n'a besoin que d'un seul parametre : le proto-mot courant
        (= la phrase au début). On cherche à identifier le proto-mot à des parties
        droites de règles. On s'arrete quand on a un axiome.<br>
        Remarques : Cet algo fonctionne sans restriction sur les règles de la grammaire /
        Complexité en n² :( / Besoin de la connaissance complète de la phrase à chaque
        fois.
      </p>
      <p>Ces algos sont faciles à implémenter et ne transforment pas la grammaire
      mais ont quand meme de gros défauts (performance / restrictions sur la grammaire
       / restrictions sur la lecture en entrée)</p>
      <p>Si on réalise des pré-traitements sur la grammaire, on peut obtenir une lecture
      dans le flux en avant limitée (on lit juste le symbole courant et le suivant)
      et de la performance (complexité linéraire généralement avec un automate à pile)</p>
    </div>
    <div class="chapitre" id="ana_descendante">
      <h2>Analyse descendante</h2>
      <p>L'algo du chapitre précédent peut être amélioré en levant la restriction sur
      les règles (qui doivent commencer par un symbole terminal). Pour cela, on cherche
      les règles associées récursivement jusqu'à ce qu'on ait un terminal &rarr;
      analyseur LL(1) ou LL(k)</p>
      <p>
        <b>Analyse prédictive : </b><br>
        <i>Premiers P(A) : </i> les premiers d'un non terminal A sont les terminaux
        qui peuvent être en tête d'une dérivation gauche de A.
        <span class="formule">P(A) = {a &isin; &Sigma; / &exist; &alpha; &isin; V*, A &rArr;* a&alpha;}</span>
        On a un problème pour les règles récursives à gauche (on écarte ou transforme
        les grammaires) et celles qui produisent des &epsilon; (qu'il faut identifier).<br>
        <br>
        <i>L'ensemble nul N : </i> l'ensemble des non-terminaux qui peuvent produire
        des &epsilon;.
        <span class="formule">N = {A &isin; N / A &rArr;* &epsilon;}</span>
        <i>Suivants S(A) : </i> les suivants d'un non-terminal A sont les terminaux
        qui peuvent suivre un non-terminal.
        <span class="formule">S(A) = {a &isin; &Sigma; / &exist;u &isin; &Sigma;*, &alpha;, &beta; &isin; V*, S (axiome) &rArr;* uA&alpha; &rArr; uAa&beta;}</span>
        Si le symbole suivant est la fin du mot, on le note avec un '$'. $ &isin; S(S).<br>
        On calcule les suivants en passant par les premiers :
        <span class="formule">S(X) = S(X) &cup; P(Y)</span>
        <small>s'il existe une règle donnant XY ou X&alpha;Y avec &alpha; &isin;
        N*</small><br>
        puis par propagation : on ajoute S(A) à S(X) pour toutes les règles A &rarr;
        &alpha;X&beta; <small>avec &beta; &isin; N*</small> et on propage sur les
        règles avec X.
      </p>
      <div class="encadre">
        <b>Analyseurs LL </b>(Analyseur Left to right Leftmost derivation) : <br>
        <br>
        <i>Principe de selection de regle</i> =
        <ul>
          <li>Si le prochain symbole n'appartient pas a P(A), on renvoie faux (sauf si A &isin; N)</li>
          <li>Si le prochain symbole est en tête d'une règle, on le lit et selectionne cette règle</li>
          <li>Si le prochain symbole &isin; P(B) <small>B un non-terminal</small>, on ne le lit pas
          mais on selectionne la règle</li>
          <li>Si A &isin; N et que le prochain symbole &isin; S(A), on renvoie true</li>
        </ul>
        Dans la fonction correspondant à un symbole, on regarde d'abord si le next()
        est dans les premiers du symbole. Ensuite, on selectionne la bonne règle, on
        appelle les fonctions des symboles concernés et on renvoie vrai si elles ont
        renvoyé vrai.
      </div>
      <p>
        Si bcp de règles et de symboles, le travail d'écriture de toutes les fonctions
        est fastidieux. On va donc passer par une matrice de transition qui va associer
        à un non-terminal et un terminal la réécriture du non-terminal (cases vides =
        erreurs).<br>
        <br>
        Pour cela, on a besoin d'une pile dans laquelle on met les proto-mots courants.
        <ul>
          <li>On initialise l'automate avec l'axiome.</li>
          <li>Quand l'entree/résultat de la table commence par un non-terminal, on
          transforme la pile</li>
          <li>Quand elle commence par un terminal, on lit le terminal et le reste
          de la partie dte remplace la partie gche</li>
          <li>Quand elle est un &epsilon;, on lit le symbole et depile le non-terminal</li>
          <li>L'automate se termine quand la pile est vide</li>
        </ul>
        <small>La pile de l'automate correspond exactement aux appels de fonctions
        que l'on aurait fait.</small><br>
        <br>
        Comme on a au plus 1 valeur par case de la table, l'analyseur est un LL(1).<br>
        <b>Grammaire LL(1) : </b> grammaire hors-contexte avec une seule transition
        possible par couple.<br>
        Parfois une grammaire n'est pas LL(1), mais on pourrait en construire une <br>
        <b>Langage LL(1) : </b> langage avec (at least) 1 grammaire LL(1) qui le génère.
      </p>
      <p>
        <b>Transformations de grammaires</b><br>
        <br>
        Le but est de se rapprocher d'une grammaire LL(1).<br>
        Pour cela, on évite les recursions gauches en les transformant en récursions
        droites avec des nouveaux non-terminaux et des &epsilon;-productions.<br>
        On a aussi un problème quand la table des prédictions a plus d'un élement
        par case (notamment quand 2 règles commencent pareil) &rarr; factorisation.<br>
      </p>
      <p>
        Parfois, il est impossible de déterminer quelle règle utiliser en ne lisant
        qu'un seul symbole &rarr; grammaires LL(k).<br> On devra donc lire plusieurs
        symboles.<br> Il existe des cas où k n'est pas borné (tend vers +&infin;)
      </p>
    </div>
    <div class="chapitre" id="ana_ascendante_intro">
      <h2>Analyse ascendante - Intro et items</h2>
      <p>
        <b>Automate à pile : </b><br>
        Automate à états finis avec une pile non bornée. Les élements dans la pile
        font partie d'un alphabet Z.<br>
        <div class="encadre">
          Un <b>automate à pile déterministe</b> est défini par :
          <ul>
            <li>&Sigma; un ensemble fini de symboles (alphabet)</li>
            <li>Q un ensemble fini d'états</li>
            <li>q0 &isin; Q, l'état initial</li>
            <li>F &sub; Q, les états finaux</li>
            <li>Z l'alphabet de pile</li>
            <li>z0 le symbole de fond de pile</li>
            <li>&delta; la fonction de transition (Qx(&Sigma; &cup; {&epsilon;})xZ &rarr; QxZ*)</li>
          </ul>
          On a autorisé les &epsilon;-transitions &rarr; il faudra s'assurer que s'il
          y a une &epsilon;-transition à partir d'un couple état/sommet de pile, il
          n'y a pas d'autre transition depuis cette configuration.
        </div>
      </p>
    </div>

    <li> <span class="formule"></span> </li>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <small><i>Notes issues du cours de Grammaires et Langages d'Eric Guérin (INSA Lyon)</i></small>
  </body>
</html>
