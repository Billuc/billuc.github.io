<!DOCTYPE html>
<html lang="fr" dir="ltr">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./coursStyle.css">
    <title>Vidéos - Grammaire et Langages</title>
  </head>
  <body>
    <div class="title">
      <h1>Grammaire et Langages</h1>
      <h2>Videos</h2>
    </div>
    <div class="chapitre" id="intro">
      <h2>Introduction générale</h2>
      <p>
        <b>Grammaires et Langages</b> : concepts théoriques en informatique mais assez
        fondamentaux.
      </p>
      <p>
        <b>3 domaines d'application : </b>
        <ul>
          <li><b>Analyse</b> : savoir si une phrase correspond à une grammaire donnée et
          traiter les résultats (le plus courant)</li>
          <li><b>Synthèse</b> : générer des phrases d'une grammaire donnée</li>
          <li><b>Inférence grammaticale</b> : générer une grammaire à partir d'échantillons
          du langage.</li>
        </ul>
      </p>
      <div class="encadre">
        <b>Definitions</b> : <br>
        <i>Grammaire</i> : décrit une syntaxe d'écriture à l'aide de règles <br>
        <i>Langage</i> : ensemble de phrases d'un alphabet <br>
        <small>Pour les grammaires, on ne parle pas d'alphabet mais de symboles terminaux </small><br>
      </div>
      <p>
        <i>Exemples de langages</i> :
        <ul>
          <li><span class="formule">{a*b*}</span> : suite de 'a' (nb qcq) suivi d'une suite de 'b' (nb qcq) <br>
          &rarr; langage régulier</li>
          <li><span class="formule">{a&#8319; b&#8319; / n>0}</span> : suite de n 'a' suivi de n 'b' (contrainte : mm nombre) <br>
          &rarr; langage non-régulier hors-contexte</li>
          <li><span class="formule">{a&#8319; b&#8319; c&#8319; / n>0}</span> : n 'a' puis n 'b' puis n 'c' <br>
          &rarr; langage contextuel (outils plus compliqués)</li>
        </ul>
        <i>Exemple de grammaire pour le langage {a*b*}</i> : <br>
        <span class="formule">
          EXP &rarr; a EXP | b EXP2 | &#949; <br>
          EXP2 &rarr; b EXP2 | &#949;
        </span>
        "&rarr;" signifie "produit", '|' signifie "ou", "&#949;" signifie "production vide"
      </p>
      <p>
        <b>Notations</b> : <br>
        Les symboles d'un alphabet (symboles terminaux) sont notés par des lettres minuscules <br>
        Les mots d'un alphabet aussi <br>
        Les symboles non-terminaux sont notés avec des lettres majuscules (ex : EXP)
      </p>
      <div class="encadre">
        <b>Définitions</b> : <br>
        <i>Proto-mot</i> : Mot avec des symboles terminaux et non-terminaux noté avec une lettre grecque <br>
        <i>Dérivation</i> : rééecriture d'un proto-mot par application d'une règle (notée &rArr;) <br>
        <i>Phrase générée par une grammaire</i> : phrase déduite par dérivations de l'axiome (symbole de départ) de la grammaire <br>
        <i>Langage généré par une grammaire</i> : ensemble des phrases générées par dérivations
      </div>
      <br>
      <div class="encadre">
          <b>Classification des grammaires</b><br>
          Grammaires à choix finis (type 4) incluses dans <br>
          Grammaires régulières (type 3) incluses dans <br>
          Grammaires hors contexte (type 2) incluses dans <br>
          Grammaires contextuelles (type 1) incluses dans <br>
          Grammaires générales (type 0) (plus de contraintes)<br>
          <br>
          <b>Notations</b> : <br>
          <ul>
            <li>T : ensemble des symboles terminaux (ou alphabet)</li>
            <li>N : ensemble des symboles non-terminaux</li>
            <li>R : ensemble des règles de la grammaire</li>
            <li>S : l'axiome de la grammaire (le symbole de départ) (S appartient à N)</li>
            <li>V : T union N</li>
          </ul>
        <p>
          <b>Grammaires générales : </b><br>
          <span class="formule">&#945; &rarr; &#946;</span>
          <small>Avec &#945; dans V*NV* et &#946; dans V*</small><br>
          Difficiles à analyser car boucle si n'appartient pas au langage (indécidable)
        </p>
        <p>
          <b>Grammaires contextuelles (ou croissantes) : </b><br>
          <span class="formule">&#945; A &#946; &rarr; &#945; &#947; &#946;</span>
          <small>Avec A dans N et &#945;, &#946;, &#947; dans V*</small><br>
          Les langages générés sont dits contextuels.
        </p>
        <p>
          <b>Grammaires hors contexte : </b><br>
          <span class="formule">A &rarr; &#947;</span>
          <small>Avec A dans N et &#947; dans V*</small><br>
          Grammaires très utilisées pour la définition de langages de programmation
          car analyse très aisée et possible. Si &#947; dans N, grammaire linéaire.
        </p>
        <p>
          <b>Grammaires régulières (ou rationnelles) : </b><br>
          Généralement sous la forme d'expressions régulières ou automates finis
          <span class="formule">A &rarr; a B</span>
          <span class="formule">A &rarr; b</span>
          <small>Avec A, B dans N et a, b dans T</small><br>
        </p>
        <p>
          <b>Grammaires à choix finis : </b><br>
          <span class="formule">A &rarr; a</span>
          <small>Avec A dans N et a dans T+</small><br>
        </p>
      </div>
      <br>
      <table>
        <th colspan="2"><b>Notation BNF (Backus Naur Form) : </b></th>
        <tr>
          <td>::=</td>
          <td>est le symbole de définition d'une règle (eq &rarr;)</td>
        </tr>
        <tr>
          <td>|</td>
          <td>est le 'ou'</td>
        </tr>
        <tr>
          <td>< ></td>
          <td>pour un symbole non-terminal</td>
        </tr>
        <tr>
          <td>[ ]</td>
          <td>pour une partie facultative</td>
        </tr>
        <tr>
          <td>{ }</td>
          <td>pour grouper des éléments</td>
        </tr>
        <tr>
          <td>" "</td>
          <td>pour les terminaux d'un seul caractère</td>
        </tr>
        <th colspan="2">EBNF (version étendue) : </th>
        <tr>
          <td>?</td>
          <td>si c'est optionnel</td>
        </tr>
        <tr>
          <td>*</td>
          <td>pour la répétition de 0 à n fois</td>
        </tr>
        <tr>
          <td>+</td>
          <td>pour la répétition de 1 à n fois</td>
        </tr>
      </table>
    </div>
    <div class="chapitre" id="ana_lexicale">
      <h2>Analyse lexicale</h2>
      <h3>Langages et expressions rationnels</h3>
      <div class="encadre">
        <b>Definitions</b><br>
        Les langages et expressions rationnels peuvent être définis de manière inductive/recursive.<br><br>
        Un <b>langage régulier</b> est défini par :
        <ul>
          <li>{&#949;} et &#216; sont des langages réguliers</li>
          <li>pour tout a dans &Sigma; (l'alphabet), {a} est un langage régulier</li>
          <li>si L1 et L2 sont des langages rationnels, alors L1 union L2, L1 L2 et L1* aussi</li>
        </ul>
        Une <b>expression régulière</b> est définie par :
        <ul>
          <li>&epsilon; est une expression régulière (mot de longueur nulle)</li>
          <li>&#216; est une expression regulière signifiant l'absence de mot</li>
          <li>pour tout a dans &Sigma;, a est une expression régulière</li>
          <li>si e1 et e2 sont des expressions régulières, (e1+e2) <small>(ou)</small>, (e1 e2) <small>(concat)</small> et (e1*) aussi</li>
        </ul>
      </div>
      <p>
        <b>Propriétés et règles simples : </b><br>
        <ul>
          <li><span class="formule">&epsilon;e = e&epsilon; = e</span></li>
          <li><span class="formule">&#216;e = e&#216; = e</span></li>
          <li>le + est commutatif (pas le concat)</li>
          <li>le + et le concat sont associatifs</li>
          <li><span class="formule">e1 (e2 + e3) = e1 e2 + e1 e3</span></li>
          <li>Priorité d'opérateurs : *, concat et +</li>
          <li><span class="formule">&#216; + e = e + &#216; = e</span></li>
          <li><span class="formule">e + e = e</span></li>
          <li><span class="formule">e* e* = e*</span></li>
          <li><span class="formule">(e*)* = e*</span></li>
          <li>etc.</li>
        </ul>
      </p>
      <p>
        Toute expression régulière décrit un et un seul langage régulier.<br>
        Deux expressions régulières décrivant un même langage sont équivalentes.
      </p>
      <h3>Les Automates Finis</h3>
      <div class="encadre">
        <b>Définitions : </b><br>
        Un automate fini déterministe est défini par :
        <ul>
          <li>&Sigma; un ensemble fini de symboles (ou alphabet)</li>
          <li>Q un ensemble fini d'états</li>
          <li>q0 de Q, l'état initial</li>
          <li>F inclus dans Q, l'ensemble des états finaux</li>
          <li>&delta; une fonction totale de Q * &Sigma; &rarr; Q, appellée fonction de transition</li>
        </ul>
        <small>Cet automate est déterministe car chaque couple (q, a) de Q * &Sigma; n'a qu'une valeur
        dans la fonction de transition.</small>
      </div>
      <p>
        En pratique, on n'exprime pas la totalité des transitions et on considère qu'on
        arrive dans un état d'erreur si la transition n'est pas explicitée.<br>
        On représente aussi la fonction de transition par une table de transition.<br>
        On représente l'automate fini par un graphe orientés où les états sont les noeuds
        et les symboles sont des étiquettes sur les arcs.
      </p>
      <div class="encadre">
        Un <b>automate déterministe</b> permet de reconnaître les mots d'un langage.<br>
        Soit &alpha; un mot. &alpha; est reconnu par l'automate A, si &delta;*(q0, &alpha;) appartient a F avec: <br>
        <ul>
          <li><span class="formule">&delta;*(q, u) = &delta;(q, u) si |u| = 1</span></li>
          <li><span class="formule">&delta;*(q, au) = &delta;*(&delta;(q, a), u) sinon</span></li>
        </ul>
        &delta;* est donc l'application successive de &delta; sur tout le mot &alpha;.<br>
        Si l'application de &delta;* n'amène pas à un état final, le mot n'est pas reconnu.<br>
      </div>
      <p>
        L'ensemble des mots reconnus par A est le langage reconnu par A.
      </p>
      <div class="encadre">
        <b>Méthode des dérivées</b><br>
        Permet de trouver un automate à partir de son expression.<br>
        Pour cela, on va dériver l'expression par rapport à un symbole.
        <span class="formule">Da(e) = {u | au appartient à e}</span>
        La dérivée de e par rapport à a est tout ce qui peut suivre a dans e (sachant que e commence par a).
        <b>Propriétés : </b>
        <ul>
          <li> <span class="formule">Da(a) = &epsilon;</span> </li>
          <li> <span class="formule">Da(b) = &#216;</span> </li>
          <li> <span class="formule">Da(e1 + e2) = Da(e1) + Da(e2)</span> </li>
          <li> <span class="formule">Da(e1e2) = Da(e1)e2 + &Delta;(e1)Da(e2)</span><br>
          On dérive e1 et on concatène e2 si e1 ne peut pas être de longueur nulle.
          Sinon, on dérive aussi e2.</li>
          <li> <span class="formule">Da(e*) = Da(e)e*</span> </li>
        </ul>
        Les états de l'automate sont les dérivées successives de l'expression.<br>
        Il y a une transition entre ei et ej sur le symbole a si Da(ej) = ei.<br>
        Un état sera final si le langage qu'il génère contient le mot vide (si on peut avoir un mot de longueur nulle).
      </div>
      <p>Il existe aussi une manière très simple de générer l'automate fini d'une
      expression mais cet automate sera non-déterministe.</p>
      <div class="encadre">
        Un <b>automate fini non-déterministe</b> est aussi défini par &Sigma;, Q, q0, F et &delta;.<br>
        La différence se fait sur le &delta; qui est maintenant une fonction de Q * &Sigma; vers 2^Q.<br>
        2^Q est l'ensemble des sous-ensembles de Q.<br>
        Il existe aussi des transitions spontanées (&epsilon;-transitions), où le symbole est &epsilon;
      </div>
      <p>
        La méthode de constuction de l'automate fini non-deterministe permet de produire des
        briques d'automate avec un état initial et un état final.
      </p>
      <div class="encadre">
        <b>Construction de Thomson : </b><br>
        <ul>
          <li>Pour un ensemble vide : pas de connexion entre l'initial et le final</li>
          <li>Pour le mot vide : &epsilon;-transition entre l'initial et le final</li>
          <li>Pour un symbole : une transition avec ce symbole entre les 2</li>
          <li>Pour un 'ou' : 2 branches avec des &epsilon;-transitions et les automates des expressions sur chaque branche</li>
          <li>Pour une concat : les automates des 2 expressions à la suite avec des &epsilon;-transitions</li>
          <li>Pour l'operateur de Kleene (e*) : on a l'automate de l'expression entre les 2 états et des &epsilon;-transitions
          entre les 2 états (I&rarr;F pour 0 répétitions et F&rarr;I pour répeter)</li>
        </ul>
      </div>
      <b>Théorème de Kleene : </b>un langage est reconnaissable par un automate fini ssi il est rationnel.
      <p>
        <b>Implémentation des automates</b><br>
        Un automate déterministe peut s'implémenter de manière procédurale, sans
        mémoire. Il suffit d'appeler la fonction de l'état cible de la transition.<br>
        On peut aussi utiliser une table de transition : map < int, map < int, int >><br>
        <small>où le premier int est l'état courant, le deuxième le symbole et le troisième l'état cible</small><br>
        <br>
        Pour un automate non-déterministe, c'est plus complexe, puisque &delta; arrive vers un ensemble d'états.<br>
        On a donc une : map < int, map < int, set < int > > ><br>
        Implémentation généralement 'de front' : on stocke des états courants, qu'on met a jour quand on lit un symbole, jusqu'a un état final.<br>
        <br>
        La complexité est bien moins importante quand l'automate est déterministe.
      </p>
      <p>
        <b>Déterminisation d'un automate : </b><br>
        On veut transformer un automate non-deterministe en automate déterministe
        pour réduire la complexité à l'execution.<br>
        Pour cela, on parcourt l'automate non-déterministe. Les noeuds de l'automate
        déterministe représentent l'ensemble des états courants dans l'automate non-déterministe.<br>
        Pour chaque ensemble d'état, on checke toutes les transitions possibles et on ajoute
        les noeuds et transitions correspondantes dans l'automate déterministe.<br>
        <small>Attention : la taille du nouvel automate peut atteindre 2^(nb de noeuds de départ)</small>
      </p>
      <p>On peut minimiser les automates obtenus (fusionner les noeuds similaires)</p>
    <!-- </div>
    <div class="chapitre" id="ana_lexicale_outils"> -->
      <h2>Analyse lexicale - Outils</h2>
      <p>
        <b>Extensions : </b><br>
        Il y a souvent des extensions (EREs) à la concatenation, l'union et l'opérateur
        de Kleene pour simplifier l'écriture.
        <ul>
          <li> <i>Classes de caractères : </i>
            <ul>
              <li><b>[...]</b> : liste de caractères autorisés (ou non-autorisés si on commence par ^)</li>
              <li>Certaines classes sont prédéclarées, comme <b>[:alpha:]</b> ou <b>[:digit:]</b></li>
              <li>Le <b>.</b> : n'importe quel caractère</li>
            </ul>
          </li>
          <li>
            <i>Cardinalités : </i>
            <ul>
              <li><b>?</b> : 0 ou 1 (donc optionnel)</li>
              <li><b>+</b> : 1 à n</li>
              <li><b>{n1, n2}</b> : de n1 à n2 caractères (Attention, très gros automates)</li>
            </ul>
          </li>
        </ul>
      </p>
      <p>
        <b>POSIX : </b><br>
        Il existe des outils CLI unix pour travailler sur des chaînes de caractères :
        <ul>
          <li><b>grep</b> filtre les lignes correspondant à une regex</li>
          <li><b>ed</b> : (vieil) éditeur de texte pour faire des modifs avec des regex</li>
          <li><b>sed</b> : editeur de flux qui lit et associe des commandes quand une regex correspond</li>
          <li><b>awk</b> : sed++</li>
          <li><b>vi</b> : editeur de texte avec qqs commandes avec regex</li>
        </ul>
        <br>
        Il y a aussi une biblio std pour utiliser les regex :
        <ul>
          <li><b>regcomp()</b> compile la regex (fabrique l'automate)</li>
          <li><b>regexec()</b> teste si la chaine satisfait la regex (execute l'automate)</li>
        </ul>
        On oublie pas de regfree() à la fin ;)
      </p>
      <p>
        <b>C++ : </b><br>
        Il y a une biblio std intégrée à la STL pour faire des regex. Attention,
        utilisez Clang/libc++ ou VS2012+.
      </p>
    </div>
    <div class="chapitre" id="ana_syntaxique">
      <h2>Analyse Syntaxique - Introduction</h2>
      <p>Rappel : grammaire hors-contexte = <span class="formule">A &rarr; &gamma;</span>
        <small>A dans N (non-terminal) et &gamma; dans V*</small><br>
        Pas aussi générales que les contextuelles mais assez expressives quand meme.<br>
      </p>
      <p>
        <b>2 manières d'analyser une grammaire hors-contexte : </b>
        <ul>
          <li>Descendante (top-down) : on part de l'axiome et on dérive jusqu'à arriver aux symboles terminaux de la phrase à analyser</li>
          <li>Ascendante (bottom-up) : on part de la phrase à analyser et on identifie des parties droites de règles (on obtient des proto-mots) jusqu'à arriver à l'axiome</li>
        </ul>
      </p>
      <p>
        <b>Algorithmes : </b><br>
        &nbsp;&nbsp;&nbsp;&nbsp;Pour l'analyse descendante, on a une fonction avec comme parametres le proto-mot
        courant et la phrase à analyser. Elle va chercher les règles associées au premier
        non-terminal du proto-mot et procéder recursivement au remplacement. On s'arrete
        quand le proto-mot = la phrase à analyser.<br>
        Problèmes : on peut boucler à l'infini, si une des règles est récursive /
        on recherche tous les proto-mots sans tenir compte de la phrase (une heuristique
        serait pas mal) / ne marche quasi que dans des cas dégénérés (grammaires à choix finis)<br>
        On peut s'assurer que les règles génèrent des symboles de la phrase (mais on
        ne peut pas avoir de non-terminaux au début &rarr; grammaires linéraires)<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;Pour l'analyse ascendante, on inverse l'analyse des règles.
        Cette fois-ci, on n'a besoin que d'un seul parametre : le proto-mot courant
        (= la phrase au début). On cherche à identifier le proto-mot à des parties
        droites de règles. On s'arrete quand on a un axiome.<br>
        Remarques : Cet algo fonctionne sans restriction sur les règles de la grammaire /
        Complexité en n² :( / Besoin de la connaissance complète de la phrase à chaque
        fois.
      </p>
      <p>Ces algos sont faciles à implémenter et ne transforment pas la grammaire
      mais ont quand meme de gros défauts (performance / restrictions sur la grammaire
       / restrictions sur la lecture en entrée)</p>
      <p>Si on réalise des pré-traitements sur la grammaire, on peut obtenir une lecture
      dans le flux en avant limitée (on lit juste le symbole courant et le suivant)
      et de la performance (complexité linéraire généralement avec un automate à pile)</p>
    </div>
    <div class="chapitre" id="ana_descendante">
      <h2>Analyse descendante</h2>
      <p>L'algo du chapitre précédent peut être amélioré en levant la restriction sur
      les règles (qui doivent commencer par un symbole terminal). Pour cela, on cherche
      les règles associées récursivement jusqu'à ce qu'on ait un terminal &rarr;
      analyseur LL(1) ou LL(k)</p>
      <p>
        <b>Analyse prédictive : </b><br>
        <i>Premiers P(A) : </i> les premiers d'un non terminal A sont les terminaux
        qui peuvent être en tête d'une dérivation gauche de A.
        <span class="formule">P(A) = {a &isin; &Sigma; / &exist; &alpha; &isin; V*, A &rArr;* a&alpha;}</span>
        On a un problème pour les règles récursives à gauche (on écarte ou transforme
        les grammaires) et celles qui produisent des &epsilon; (qu'il faut identifier).<br>
        <br>
        <i>L'ensemble nul N : </i> l'ensemble des non-terminaux qui peuvent produire
        des &epsilon;.
        <span class="formule">N = {A &isin; N / A &rArr;* &epsilon;}</span>
        <i>Suivants S(A) : </i> les suivants d'un non-terminal A sont les terminaux
        qui peuvent suivre un non-terminal.
        <span class="formule">S(A) = {a &isin; &Sigma; / &exist;u &isin; &Sigma;*, &alpha;, &beta; &isin; V*, S (axiome) &rArr;* uA&alpha; &rArr; uAa&beta;}</span>
        Si le symbole suivant est la fin du mot, on le note avec un '$'. $ &isin; S(S).<br>
        On calcule les suivants en passant par les premiers :
        <span class="formule">S(X) = S(X) &cup; P(Y)</span>
        <small>s'il existe une règle donnant XY ou X&alpha;Y avec &alpha; &isin;
        N*</small><br>
        puis par propagation : on ajoute S(A) à S(X) pour toutes les règles A &rarr;
        &alpha;X&beta; <small>avec &beta; &isin; N*</small> et on propage sur les
        règles avec X.
      </p>
      <div class="encadre">
        <b>Analyseurs LL </b>(Analyseur Left to right Leftmost derivation) : <br>
        <br>
        <i>Principe de selection de regle</i> =
        <ul>
          <li>Si le prochain symbole n'appartient pas a P(A), on renvoie faux (sauf si A &isin; N)</li>
          <li>Si le prochain symbole est en tête d'une règle, on le lit et selectionne cette règle</li>
          <li>Si le prochain symbole &isin; P(B) <small>B un non-terminal</small>, on ne le lit pas
          mais on selectionne la règle</li>
          <li>Si A &isin; N et que le prochain symbole &isin; S(A), on renvoie true</li>
        </ul>
        Dans la fonction correspondant à un symbole, on regarde d'abord si le next()
        est dans les premiers du symbole. Ensuite, on selectionne la bonne règle, on
        appelle les fonctions des symboles concernés et on renvoie vrai si elles ont
        renvoyé vrai.
      </div>
      <p>
        Si bcp de règles et de symboles, le travail d'écriture de toutes les fonctions
        est fastidieux. On va donc passer par une matrice de transition qui va associer
        à un non-terminal et un terminal la réécriture du non-terminal (cases vides =
        erreurs).<br>
        <br>
        Pour cela, on a besoin d'une pile dans laquelle on met les proto-mots courants.
        <ul>
          <li>On initialise l'automate avec l'axiome.</li>
          <li>Quand l'entree/résultat de la table commence par un non-terminal, on
          transforme la pile</li>
          <li>Quand elle commence par un terminal, on lit le terminal et le reste
          de la partie dte remplace la partie gche</li>
          <li>Quand elle est un &epsilon;, on lit le symbole et depile le non-terminal</li>
          <li>L'automate se termine quand la pile est vide</li>
        </ul>
        <small>La pile de l'automate correspond exactement aux appels de fonctions
        que l'on aurait fait.</small><br>
        <br>
        Comme on a au plus 1 valeur par case de la table, l'analyseur est un LL(1).<br>
        <b>Grammaire LL(1) : </b> grammaire hors-contexte avec une seule transition
        possible par couple.<br>
        Parfois une grammaire n'est pas LL(1), mais on pourrait en construire une <br>
        <b>Langage LL(1) : </b> langage avec (at least) 1 grammaire LL(1) qui le génère.
      </p>
      <p>
        <b>Transformations de grammaires</b><br>
        <br>
        Le but est de se rapprocher d'une grammaire LL(1).<br>
        Pour cela, on évite les recursions gauches en les transformant en récursions
        droites avec des nouveaux non-terminaux et des &epsilon;-productions.<br>
        On a aussi un problème quand la table des prédictions a plus d'un élement
        par case (notamment quand 2 règles commencent pareil) &rarr; factorisation.<br>
      </p>
      <p>
        Parfois, il est impossible de déterminer quelle règle utiliser en ne lisant
        qu'un seul symbole &rarr; grammaires LL(k).<br> On devra donc lire plusieurs
        symboles.<br> Il existe des cas où k n'est pas borné (tend vers +&infin;)
      </p>
    </div>
    <div class="chapitre" id="ana_ascendante_intro">
      <h2>Analyse ascendante - Intro et items</h2>
      <p>
        <b>Automate à pile : </b><br>
        Automate à états finis avec une pile non bornée. Les élements dans la pile
        font partie d'un alphabet Z.
      </p>
      <div class="encadre">
        Un <b>automate à pile déterministe</b> est défini par :
        <ul>
          <li>&Sigma; un ensemble fini de symboles (alphabet)</li>
          <li>Q un ensemble fini d'états</li>
          <li>q0 &isin; Q, l'état initial</li>
          <li>F &sub; Q, les états finaux</li>
          <li>Z l'alphabet de pile</li>
          <li>z0 le symbole de fond de pile</li>
          <li>&delta; la fonction de transition (Qx(&Sigma; &cup; {&epsilon;})xZ &rarr; QxZ*)</li>
        </ul>
        On a autorisé les &epsilon;-transitions &rarr; il faudra s'assurer que s'il
        y a une &epsilon;-transition à partir d'un couple état/sommet de pile, il
        n'y a pas d'autre transition depuis cette configuration.
      </div>
      <p>
        On peut faire une représentation graphique s'un tel automate. Pour cela
        il faut rajouter l'info concernant la pile sur l'arc. <i>Exemple d'arc :
        a[e &rarr; fg].</i><br>
        Cet automate permet aussi de reconnaître des mots si on arrive dans un état
        final après l'execution de l'automate. On reconnait aussi un mot si on
        arrive à une pile vide à la fin (définition plus utilisée).
      </p>
      <div class="encadre">
        <b>Automates à pile non-deterministes : </b><br>
        &delta; (la fonction de transition) est maintenant une fonction de
        Qx(&Sigma; &cup; {&epsilon;})xZ vers 2^(QxZ*)<br>
        <br>
        Ces automates ont un pouvoir d'expression plus fort et permettent donc
        de décrire plus de langages. Il n'y a donc pas d'equivalence entre les
        automates à pile deterministes et non-deterministes. On va donc devoir
        construire directement les automates deterministes.
      </div>
      <p><small>
        Généralement, Q = Z (on empile donc des états). C'est le cas des automates
        à items.
      </small></p>
      <p>
        <b>Automates à items : </b><br>
        Il permet de construire un automate à pile <b>non-deterministe</b> (donc
        non-utilisable en pratique) d'une grammaire hors-contexte.<br>
      </p>
      <p>
        Un <b>item</b> est de la forme :
        <span class="formule">[X &rarr; &alpha; &sdot; &beta;]</span>
        Cela veut dire que dans l'application de la règle X &rarr; &alpha;&beta;,
        on a déjà dérivé un mot de &alpha; et il reste à dériver un mot de &beta;.
        Le point est un curseur qui dit où on en est dans l'analyse.<br>
        <small>"X &rarr; &sdot;" correspond à la production vide.</small>
      </p>
      <p>
        En général, on ajoute un nouvel axiome qui n'intervient que en partie
        gauche et jamais en partie droite. Quand cet axiome est reconnu, on sait
        que l'on a fini.
      </p>
      <div class="encadre">
        <b>Automate des items : </b><br>
        Les items sont à la fois les états et l'alphabet de pile. L'ensemble des
        items est noté Zg. On modifie la fonction de transition pour pouvoir
        regarder 1 ou 2 elements de la pile.
        <span class="formule">&delta; : (Zg &cup; (Zg x Zg)) x (E &cup; {&epsilon;})
        &rarr; Zg*</span>
        <br>
        <b>Transitions : </b><br>
        <i>Transition de lecture : </i>dans l'état [X&rarr;&alpha;&sdot;a&beta;],
        si le prochain symbole à lire est 'a', on remplace le haut de la pile par
        [X&rarr;&alpha;a&sdot;&beta;].<br>
        <small>La taille de la pile ne change pas et c'est la seule transition
        qui ne soit pas une &epsilon;-transition.</small><br>
        <i>Transition d'expansion : </i>dans l'état [X&rarr;a&sdot;Yb], si on a
        une règle Y&rarr;&gamma;, on peut empiler l'item [Y&rarr;&sdot;&gamma;].<br>
        <small>La taille de la pile augmente de 1</small><br>
        <i>Transition de réduction : </i>dans l'état [X&rarr;a&sdot;Yb][Y&rarr;&gamma;&sdot;],
        on a reconnu Y, donc la pile devient [X&rarr;aY&sdot;b].<br>
        <small>La taille de la pile diminue de 1 (car on a dépilé le second item).</small>
      </div>
      <p>
        <i>Théorème : </i>le langage reconnu par l'automate non-deterministe d'une
        grammaire est le langage associé à cette grammaire. <br>
        Comme l'automate est non-déterministe, il est suseptible de tourner en
        boucle en pratique.
      </p>
      <p>
        On va donc construire des automates deterministes directement (prochains
        chapitres) quitte a restreindre les grammaires utilisables.
      </p>
    </div>

    <div class="chapitre" id="ana_lr0">
      <h2>Automate LR0</h2>
      <p>
        Les automates des items posent problème à cause des &epsilon;-transitions.<br>
        L'automate LR(0) regroupe les items en fonction de ces transitions et est
        donc stable par les &epsilon;-transitions (on a plus de transition de réduction,
        elles seront implicites).
      </p>
      <p>
        On met les transitions d'expansion dans les états pour avoir la stabilité :
        lorsqu'on a un non-terminal à droite d'un point, on ajoute les règles avec
        ce non-terminal en partie gauche dans le même état.<br>
        On a aussi des transitions avec des non-terminaux, qui correspondent aux
        réductions (items puits).
      </p>
      <div class="encadre">
        <b>Construction de l'automate : </b><br>
        On commence par la règle de l'axiome (du type S' &rarr; S).<br>
        On complete de manière récursive l'état en ajoutant les règles dont les parties
        gauches se trouvent directement à droite d'un point (saturation).<br>
        On construit ensuite les transitions avec tous les symboles (terminaux et
        non-terminaux). On arrive dans des états où l'on a décalé le point et on
        sature ici aussi.<br>
        On réalise cela récursivement en fusionnant les états identiques.
      </div>
      <p>
        Ici aussi, on a les transitions de lecture et de réduction, mais on n'a
        plus besoin de transition d'expansion (elle se fait en même temps que la
        lecture).<br>
        /!\ Lors d'une réduction, on dépile autant d'états qu'il y a d'élements
        en partie droite
      </p>
      <p>
        <b>Table d'analyse : </b><br>
        On modélise l'automate par une table d'analyse avec pour entrées l'état
        courant et symbole (terminal ou non-terminal). Lors d'un décalage, on indique
        l'état dans lequel on arrive. Lors d'une réduction, on indique la règle
        réduite. On devra conserver le nombre d'états à dépiler et le symbole
        non-terminal créé.<br>
        Il n'y a pas de réduction de l'axiome, mais une acceptation.<br>
        On met des cases vides dans le cas des erreurs (phrase non reconnue). <br>
      </p>
      <p>
        Les automates LR(0) sont implémentés très facilement en utilisant le design
        pattern State. On créé une classe-état par état et on les met dans une pile.
        L'état en haut de la pile est l'état courant. Pour chaque état, l'action
        à réaliser par symbole est différente (fonction de transition différente).
      </p>
      <p>
        <b>Limitations : </b><br>
        Lors de la construction, il est possible que plusieurs possibilités soient
        faisables en même temps (conflit).<br>
        <i>Exemple : </i> A&rarr;a|&epsilon;, est-ce que A donne a ou &epsilon; ?
        Les 2 sont possibles !<br>
        Il y a
        <ul>
          <li>les conflits décalage/réduction : dans un même état, on peut faire
          un décalage et une réduction</li>
          <li>les conflits réduction/réduction : dans un même état, on peut faire
          2 réductions différentes</li>
        </ul>
        On peut résoudre les conflits en lisant le symbole d'après &rarr; analyseurs
        LR(1) et SLR(1) (version simplifiée).
      </p>
      <p><b>Grammaire LR(0) : </b>si la table des actions ne contient aucun conflit.</p>
    </div>

    <div class="chapitre" id="ana_slr1">
      <h2>Automate SLR(1)</h2>
      <p>
        Version améliorée de LR(0), vu qu'on lit un caractère en avance (d'où le
        1).<br>
        En gros, on ne fait une réduction de X que si le prochain terminal est un
        suivant de X.<br>
        <i>Remarque : </i>SLR(1) utilise le même automate (même graphe) que LR(0).<br>
        <br>
        Dans cet automate, on ne réduit une règle que si le terminal suivant fait
        partie des suivants du symbole. Cela permet de lever des conflits. On peut
        avoir des décalages et des réductions sur une même ligne avec cet automate.
        <br>
        Pour implémenter cet automate, on aura besoin d'une fonction qui sonde le
        prochain caractère sans le consommer.
      </p>
      <p>
        Une grammaire ambigüe ne peut pas être LR(0) ou SLR(1) et une grammaire
        LR(0) ou SLR(1) ne peut pas être ambigüe.
      </p>
      <p>
        Avec un automate SLR(1), la récursivité à gauche et à droite sont gérées,
        mais la récursivité gauche est bien plus simple à traiter. L'automate dans
        ce cas est bien plus performant (le nombre d'états empilés ne dépend pas
        du nombre de symboles lus).<br>
        Dans le cas d'une récursivité droite, le nombre d'états empilés correspond
        au nombre de symboles lus (en gros).
      </p>
      <p><b>Grammaire SLR(1) : </b>si on a aucun conflit.</p>
    </div>

    <div class="chapitre" id="ana_lr1">
      <h2>Analyseurs LR(1)</h2>
      <p>Les analyseurs SLR(1) prennent en compte les suivants d'un non-terminal
      mais pas dans un contexte. Les analyseurs LR(1), eux, identifient les suivants
      d'un non-terminal par item.</p>
      <p><b>Items généralisés : </b><br>
        Extension des items : on ajoute les terminaux qui peuvent suivre le non-terminal
        en partie gauche.
      </p>
      <p>
        <b>Saturation des items : </b><br>
        Quand on veut saturer [X &rarr; &alpha;&sdot;Y&beta;, a], on ajoute
        les règles avec Y en partie gauche et les suivants pour ses règles seront
        les premiers de "&beta; a" (a peut être dedans si &beta; peut être nul).
      </p>
      <p>
        La table d'analyse est très similaire mais les réductions sont très ciblées.
        <b>Grammaire LR(1) : </b>la table d'analyse ne contient pas de conflits.
      </p>
      <small>Un automate LR(1) aura plus d'états qu'un automate LR(0) ou SLR(1)
        (parfois beaucoup plus &rarr; lourd). On a donc un intermédiaire entre SLR(1)
        et LR(1) : LALR(1) (utilisé par bison notamment).
      </small>
      <h2>Analyseurs LALR(1)</h2>
      <p>On construit l'automate LALR(1) à partir de l'automate LR(1). On fusionne
      les états avec le même coeur (regardless of les symboles de prédiction) qui
      ne génèrent pas de conflits et qui ont un comprtement similaire.</p>
      <br>
      <p>Les grammaires ascendantes sont plus puissantes que les grammaires
      descendantes équivalentes (LR(0) > LL(0), LR(k) > LL(k)) car elles permettent
      la récursivité à gauche</p>
    </div>

    <div class="chapitre" id="gram_attribuees">
      <h2>Grammaires attribuées</h2>
      <p>
        Principe : à chaque symbole (terminal ou non-terminal), on associe un ou
        plusieurs attributs qui permettent d'associer une sémantique aux noeuds.
        Ces attributs peuvent être hérités (du parent vers le fils) ou synthétisé
        (du fils vers le parent).
      </p>
      <p>
        On peut formaliser le calcul d'attributs en l'écrivant entre parenthèses
        (cela permet de formaliser des opérations arithmétiques notamment). On peut
        aussi associer des "variables" pour chaque noeud et écrire leur relation
        entre accolades après (cela formalise plus un algorithme). etc.
      </p>
      <p>
        <b>Types de grammaires attribuées : </b><br>
        Soit une règle <span class="formule">A &rarr; A1 A2 ... An</span>
        <ul>
          <li>Grammaire L-attribuée : l'attribut de Ai dépend des attributs des
          symboles à sa gauche (A et A1 : A(i-1))</li>
          <li>Grammaire S-attribuée : l'attribut de A dépend des attributs des Ai</li>
        </ul>
        Exemple: en compilation, on a souvent des L-attribuées, notamment pour la
        déclaration de variables (on transmet de type de gauche à droite). Il est
        aussi possible de le faire avec une grammaire S-attribuée tho.
      </p>
      <p>
        <b>Calcul : </b><br>
        2 solutions :
        <ul>
          <li>Calcul après analyse : parcours de l'arbre</li>
          <li>Calcul pendant analyse : plus ou moins aisé</li>
        </ul>
        Si après analyse, besoin d'un graphe de dépendance entre attributs. S'il
        n'y a pas de cycle, on peut tous les calculer.<br>
        Si pendant analyse, les L-attribuées sont plus adaptés pour les analyseurs LL
        et les S-attribuées pour les LR.
      </p>
    </div>

    <li> <span class="formule"></span> </li>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <small><i>Notes issues du cours de Grammaires et Langages d'Eric Guérin (INSA Lyon)</i></small>
  </body>
</html>
